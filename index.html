<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNC Simulator</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div id="horni-panel">
            <div class="tab-buttons">
                <button class="menu-button" onclick="toggleMenu('left')">üìÇ</button>
                <button onclick="switchTab('parser')" class="tab-button active" id="parserTab">Parser</button>
                <button onclick="switchTab('simulator')" class="tab-button" id="simulatorTab">Simulace</button>
                <button class="menu-button" onclick="toggleMenu('right')">üìã</button>
            </div>
            <div id="parserContent">
                <textarea id="parserOutput" readonly></textarea>
            </div>
            <div id="simulatorContent">
                <canvas id="simulatorCanvas"></canvas>
            </div>
        </div>

        <div id="separator">
            <div class="separator-content">
                <div class="player-container">
                    <div class="player-buttons">
                        <button class="player-button" title="Krok zpƒõt">‚è™</button>
                        <button class="player-button" title="Spustit/Pozastavit">‚èØÔ∏è</button>
                        <button class="player-button" title="Krok vp≈ôed">‚è©</button>
                    </div>
                </div>
            </div>
            <div class="resize-handle" title="Zmƒõnit velikost"></div>
        </div>

        <div id="dolni-panel">
            <div id="editor">
                <textarea id="codeEditor" spellcheck="false"></textarea>
            </div>
        </div>
    </div>

    <!-- Menu panely - opraven√© duplicity -->
    <div id="leftMenu" class="side-menu">
        <button class="close-btn" onclick="toggleMenu('left')">‚úñ</button>
        <button onclick="openFileMenu()">Otev≈ô√≠t Program</button>
    </div>

    <div id="rightMenu" class="side-menu">
        <button class="close-btn" onclick="toggleMenu('right')">‚úñ</button>
        <div id="programList"></div>
    </div>

    <!-- Ovl√°dac√≠ tlaƒç√≠tka - opraven√© duplicity -->
    <div class="controls">
        <button onclick="toggleMenu('left')">üìÇ</button>
        <button onclick="toggleMenu('right')">üìã</button>
    </div>

    <script>
        // Vlo≈æ√≠me k√≥d ze simulator.js
        class Simulator {
            constructor() {
                this.canvas = document.getElementById('simulatorCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.scale = 1;
                this.offsetX = 0;
                this.offsetY = 0;
                this.toolPath = [];
                this.setupCanvas();
            }

            setupCanvas() {
                if (!this.canvas) return;

                const mmToPx = 3.78;
                const marginX = 5 * mmToPx;
                const marginY = 5 * mmToPx;

                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                this.offsetX = marginX;
                this.offsetY = this.canvas.height - marginY * 4;

                this.draw();
            }

            draw() {
                if (!this.ctx) return;

                this.ctx.save();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.translate(this.offsetX, this.offsetY);
                this.ctx.scale(this.scale, -this.scale);

                this.drawGrid();
                this.drawAxes();
                this.drawToolPath();

                this.ctx.restore();
            }

            drawGrid() {
                // Implementace vykreslen√≠ m≈ô√≠≈æky
                const size = Math.max(this.canvas.width, this.canvas.height) / this.scale;
                const gridSize = 50;
                const numSquares = Math.ceil(size / gridSize);

                this.ctx.strokeStyle = '#ddd';
                this.ctx.lineWidth = 0.5 / this.scale;

                for (let i = -numSquares; i <= numSquares; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i * gridSize, -size);
                    this.ctx.lineTo(i * gridSize, size);
                    this.ctx.stroke();

                    this.ctx.beginPath();
                    this.ctx.moveTo(-size, i * gridSize);
                    this.ctx.lineTo(size, i * gridSize);
                    this.ctx.stroke();
                }
            }

            drawAxes() {
                const size = Math.max(this.canvas.width, this.canvas.height) / this.scale;
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = 2 / this.scale;

                this.ctx.beginPath();
                this.ctx.moveTo(-size, 0);
                this.ctx.lineTo(size, 0);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(0, -size);
                this.ctx.lineTo(0, size);
                this.ctx.stroke();
            }

            drawToolPath() {
                if (!this.toolPath.length) return;

                this.ctx.strokeStyle = 'blue';
                this.ctx.lineWidth = 2 / this.scale;
                this.ctx.beginPath();

                this.toolPath.forEach(([x, z], i) => {
                    if (i === 0) {
                        this.ctx.moveTo(z, -x);
                    } else {
                        this.ctx.lineTo(z, -x);
                    }
                });

                this.ctx.stroke();
            }

            updateToolPath(path) {
                this.toolPath = path || [];
                this.draw();
            }
        }

        // Nahrad√≠me pr√°zdnou t≈ô√≠du Parser kompletn√≠ implementac√≠
        class Parser {
            constructor() {
                this.toolPath = [];
                this.output = document.getElementById('parserOutput');
                this.setupParserEvents();
            }

            parse(code) {
                if (!code || code.trim() === '') {
                    if (this.output) this.output.value = "1: \n2: ";
                    this.toolPath = [[0, 0]];
                    return;
                }

                const lines = code.split('\n');
                let currentX = 0;
                let currentZ = 0;
                this.toolPath = [[currentX, currentZ]];

                const parsedLines = lines.map((line, index) => {
                    let parsed = `${index + 1}: `;
                    const parts = line.trim().toUpperCase().split(' ');

                    let newX = currentX;
                    let newZ = currentZ;

                    for (const part of parts) {
                        if (part.startsWith('G')) {
                            parsed += '[G-k√≥d] ';
                        } else if (part.startsWith('M')) {
                            parsed += '[M-k√≥d] ';
                        } else if (part.startsWith('X')) {
                            newX = parseFloat(part.slice(1)) || currentX;
                        } else if (part.startsWith('Z')) {
                            newZ = parseFloat(part.slice(1)) || currentZ;
                        }
                    }

                    if (newX !== currentX || newZ !== currentZ) {
                        this.toolPath.push([newX, newZ]);
                        currentX = newX;
                        currentZ = newZ;
                    }

                    parsed += line;
                    return parsed;
                });

                if (this.output) {
                    this.output.value = parsedLines.join('\n');
                }
            }

            setupParserEvents() {
                this.output.addEventListener('click', (e) => {
                    const text = this.output.value;
                    const pos = this.output.selectionStart;
                    const lines = text.substr(0, pos).split('\n');
                    const lineNumber = lines.length;
                    this.selectLine(lineNumber);
                });
            }

            selectLine(lineNumber) {
                const lines = this.output.value.split('\n');
                if (lineNumber < 1 || lineNumber > lines.length) return;

                // Najdeme pozici zaƒç√°tku a konce ≈ô√°dku
                let start = 0;
                for (let i = 0; i < lineNumber - 1; i++) {
                    start += lines[i].length + 1;
                }
                const end = start + lines[lineNumber - 1].length;

                // Oznaƒç√≠me ≈ô√°dek
                this.output.focus();
                this.output.setSelectionRange(start, end);

                // Ode≈°leme ud√°lost o zmƒõnƒõ vybran√©ho ≈ô√°dku
                if (this.onLineSelected) {
                    this.onLineSelected(lineNumber);
                }
            }
        }

        // Vlo≈æ√≠me k√≥d z editor.js
        class Editor {
            constructor() {
                this.editor = document.getElementById('codeEditor');
                this.selectedLine = 1;
                this.setupEditor();
            }

            setupEditor() {
                // Inicializace editoru
                this.editor.value = "1: \n2: ";

                // P≈ôid√°n√≠ event listener≈Ø
                this.editor.addEventListener('input', (e) => {
                    const text = this.editor.value;
                    const cursorPos = this.editor.selectionStart;
                    const lines = text.split('\n').map(line =>
                        line.replace(/^\d+:\s*|\[G-k√≥d\]\s*|\[M-k√≥d\]\s*/g, ''));
                    const formattedLines = lines.map((line, i) => this.formatLine(line, i));

                    this.editor.value = formattedLines.join('\n');
                    this.editor.selectionStart = this.editor.selectionEnd = cursorPos;

                    if (this.onCodeChange) {
                        this.onCodeChange(lines.join('\n'));
                    }
                });

                this.editor.addEventListener('click', (e) => {
                    const text = this.editor.value;
                    const pos = this.editor.selectionStart;
                    const lines = text.substr(0, pos).split('\n');
                    const lineNumber = lines.length;
                    this.selectLine(lineNumber);
                });
            }

            selectLine(lineNumber) {
                const lines = this.editor.value.split('\n');
                if (lineNumber < 1 || lineNumber > lines.length) return;

                let start = 0;
                for (let i = 0; i < lineNumber - 1; i++) {
                    start += lines[i].length + 1;
                }
                const end = start + lines[lineNumber - 1].length;

                this.editor.focus();
                this.editor.setSelectionRange(start, end);
                this.selectedLine = lineNumber;

                if (this.onLineSelected) {
                    this.onLineSelected(lineNumber);
                }
            }

            formatLine(line, index) {
                // P≈ôid√°me stejnou logiku jako v parseru pro rozpozn√°v√°n√≠ k√≥d≈Ø
                const lineNumber = index + 1;
                const prefix = lineNumber < 10 ? ' ' : '';
                let parsed = `${prefix}${lineNumber}: `;

                // Rozpozn√°v√°n√≠ k√≥d≈Ø stejnƒõ jako v parseru
                const parts = line.trim().toUpperCase().split(' ');
                let hasGCode = false;
                let hasMCode = false;

                for (const part of parts) {
                    if (part.startsWith('G')) hasGCode = true;
                    if (part.startsWith('M') || part.startsWith('MSG')) hasMCode = true;
                }

                // P≈ôid√°me znaƒçky k√≥d≈Ø
                if (hasGCode) parsed += '[G-k√≥d] ';
                if (hasMCode) parsed += '[M-k√≥d] ';

                return parsed + line;
            }

            loadProgram(program) {
                if (!program) return;

                const lines = program.split('\n');
                const formattedLines = lines.map((line, i) => this.formatLine(line, i));
                this.editor.value = formattedLines.join('\n');
            }
        }

        class App {
            constructor() {
                this.simulator = new Simulator();
                this.parser = new Parser();
                this.setupEditor();
                this.setupCommunication();
                this.setupEventListeners();
                this.initializePanels();

                // P≈ôid√°me glob√°ln√≠ reference na metody
                window.toggleMenu = this.toggleMenu.bind(this);
                window.switchTab = this.switchTab.bind(this);
                window.openFileMenu = this.openFileMenu.bind(this);ditor(); // P≈ôid√°me instanci Editor t≈ô√≠dy

                // Nastav√≠me v√Ωchoz√≠ z√°lo≈æku na parser
                this.switchTab('parser');

                // P≈ôid√°me propojen√≠ mezi editorem a parserem
                this.editor.onLineSelected = (lineNumber) => {
                    this.parser.selectLine(lineNumber);
                };

                this.parser.onLineSelected = (lineNumber) => {
                    this.editor.selectLine(lineNumber);
                };            }
            }

            initializePanels() {
                const horniPanel = document.getElementById('horni-panel');is.editor.onCodeChange = (code) => {
                if (horniPanel) {                    this.parser.parse(code);
                    // Nastav√≠me v√Ωchoz√≠ v√Ω≈°ku horn√≠ho panelu na polovinu dostupn√© v√Ω≈°kytoolPath);
                    const dostupnaVyska = window.innerHeight;
                    const separatorVyska = 60;
                    const vyskaHorniho = Math.floor((dostupnaVyska - separatorVyska) / 2);   // Propojen√≠ synchronizace ≈ô√°dk≈Ø
                    horniPanel.style.height = `${vyskaHorniho}px`;                this.editor.onLineSelected = (lineNumber) => {
                }selectLine(lineNumber);
            }

            // P≈ôid√°me metody pro p≈ôep√≠n√°n√≠ menu
            toggleMenu(side) {
                const menu = document.getElementById(`${side}Menu`);
                const otherSide = side === 'left' ? 'right' : 'left';
                const otherMenu = document.getElementById(`${otherSide}Menu`);
alizePanels() {
                if (menu) {   const horniPanel = document.getElementById('horni-panel');
                    menu.classList.toggle('visible');                if (horniPanel) {
                    if (otherMenu && otherMenu.classList.contains('visible')) {orn√≠ho panelu na polovinu dostupn√© v√Ω≈°ky
                        otherMenu.classList.remove('visible');upnaVyska = window.innerHeight;
                    }
                }separatorVyska) / 2);
            }
                }
            // P≈ôid√°me metodu pro p≈ôep√≠n√°n√≠ z√°lo≈æek
            switchTab(tab) {
                const parserContent = document.getElementById('parserContent');
                const simulatorContent = document.getElementById('simulatorContent');
                const parserTab = document.getElementById('parserTab'); menu = document.getElementById(`${side}Menu`);
                const simulatorTab = document.getElementById('simulatorTab');onst otherSide = side === 'left' ? 'right' : 'left';
   const otherMenu = document.getElementById(`${otherSide}Menu`);
                if (tab === 'parser') {
                    parserContent.style.display = 'block';
                    simulatorContent.style.display = 'none';ssList.toggle('visible');
                    parserTab.classList.add('active');
                    simulatorTab.classList.remove('active');
                } else {
                    parserContent.style.display = 'none';
                    simulatorContent.style.display = 'block';            }
                    parserTab.classList.remove('active');
                    simulatorTab.classList.add('active');
                    this.simulator.setupCanvas(); // Aktualizujeme canvas p≈ôi p≈ôepnut√≠
                }entById('parserContent');
            }ById('simulatorContent');
rserTab = document.getElementById('parserTab');
            setupEditor() {yId('simulatorTab');
                this.editor = document.getElementById('codeEditor');
                if (!this.editor) {
                    console.error('Editor element not found');;
                    return;
                }   parserTab.classList.add('active');
       simulatorTab.classList.remove('active');
                this.editor.addEventListener('input', (e) => {                } else {
                    const code = e.target.value;ontent.style.display = 'none';
                    this.parser.parse(code);
                    this.simulator.updateToolPath(this.parser.toolPath);List.remove('active');
                });
            }mulator.setupCanvas(); // Aktualizujeme canvas p≈ôi p≈ôepnut√≠

            setupCommunication() {            }
                window.addEventListener('message', (event) => {
                    if (event.data.action === 'codeChanged') {
                        this.parser.parse(event.data.code);t.querySelector('.resize-handle');
                        this.simulator.updateToolPath(this.parser.toolPath););
                    }st dolniPanel = document.getElementById('dolni-panel');
                });   let isResizing = false;
            }
entListener('mousedown', (e) => {
            setupEventListeners() {
                const resizeHandle = document.querySelector('.resize-handle');
                const horniPanel = document.getElementById('horni-panel');
                const dolniPanel = document.getElementById('dolni-panel');
                let isResizing = false;
 const startY = e.pageY;
                resizeHandle.addEventListener('mousedown', (e) => {       const startHeight = horniPanel.offsetHeight;
                    if (e.button !== 0) return;
                    e.preventDefault();(e) => {
                    e.stopPropagation();
                    isResizing = true;nerHeight - 260,

                    const startY = e.pageY;e.height = `${newHeight}px`;
                    const startHeight = horniPanel.offsetHeight;                        this.simulator.setupCanvas(); // Zmƒõnƒõno z handleResize na setupCanvas

                    const onMove = (e) => {
                        if (!isResizing) return;{
                        const newHeight = Math.max(100, Math.min(window.innerHeight - 260,se;
                            startHeight + e.pageY - startY));eEventListener('mousemove', onMove);
                        horniPanel.style.height = `${newHeight}px`;                        document.removeEventListener('mouseup', onUp);
                        this.simulator.setupCanvas(); // Zmƒõnƒõno z handleResize na setupCanvas
                    };
                    document.addEventListener('mousemove', onMove);
                    const onUp = () => {er('mouseup', onUp);
                        isResizing = false;
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                    };

                    document.addEventListener('mousemove', onMove);fileInput = document.createElement('input');
                    document.addEventListener('mouseup', onUp);                fileInput.type = 'file';
                });, .spf';
            }

            // P≈ôidan√° metoda pro otev≈ôen√≠ soubor≈Ø
            openFileMenu() {nst files = Array.from(fileInput.files);
                const fileInput = document.createElement('input');                    const promises = files.map(file => {
                fileInput.type = 'file';
                fileInput.accept = '.mpf, .spf';
                fileInput.multiple = true;         reader.onload = (e) => {
                   const program = e.target.result;
                fileInput.onchange = (e) => {                                if (this.editor) {
                    const files = Array.from(fileInput.files);lov√°n√≠ ≈ô√°dk≈Ø p≈ôi naƒçten√≠
                    const promises = files.map(file => {        const lines = program.split('\n');
                        return new Promise((resolve) => {p((line, i) => {
                            const reader = new FileReader();const lineNumber = i + 1;
                                        const prefix = lineNumber < 10 ? ' ' : '';=> {
                                        return `${prefix}${lineNumber}: ${line}`;ram = e.target.result;
                                    });                                if (this.editor) {
                                    this.editor.value = numberedLines.join('\n');e ƒç√≠slov√°n√≠ ≈ô√°dk≈Ø p≈ôi naƒçten√≠
t('\n');
                                    // Spustit parser na nov√Ω k√≥d= lines.map((line, i) => {
                                    this.parser.parse(program);= i + 1;
                                    this.simulator.updateToolPath(this.parser.toolPath);umber < 10 ? ' ' : '';
                                }efix}${lineNumber}: ${line}`;
                                resolve();
                            };lue = numberedLines.join('\n');
                            reader.readAsText(file);
                        });
                    });
(this.parser.toolPath);
                    Promise.all(promises).then(() => {
                        console.log('V≈°echny programy byly naƒçteny.');
                        this.loadProgramList(files);
                        this.toggleMenu('left');
                    });                        });
                };

                fileInput.click();
            }og('V≈°echny programy byly naƒçteny.');
st(files);
            loadProgramList(files) {oggleMenu('left');
                const programList = document.getElementById('programList');
                if (!programList) return;

                programList.innerHTML = '';                fileInput.click();
                files.forEach(file => {
                    const div = document.createElement('div');
                    div.textContent = file.name;
                    div.style.padding = '8px';ElementById('programList');
                    div.style.cursor = 'pointer';ogramList) return;
                    div.style.borderBottom = '1px solid #eee';
                programList.innerHTML = '';
                    div.onclick = () => { => {
                        const reader = new FileReader();       const div = document.createElement('div');
                        reader.onload = (e) => {                    div.textContent = file.name;
                            if (this.editor) {g = '8px';
                                const program = e.target.result;
                                // P≈ôid√°me ƒç√≠slov√°n√≠ ≈ô√°dk≈Ø p≈ôi naƒçten√≠ z programListm = '1px solid #eee';
                                const lines = program.split('\n');
                                const numberedLines = lines.map((line, i) => {
                                    const lineNumber = i + 1;new FileReader();
                                    const prefix = lineNumber < 10 ? ' ' : '';
                                    return `${prefix}${lineNumber}: ${line}`;
                                });= e.target.result;
                                this.editor.value = numberedLines.join('\n');√°n√≠ ≈ô√°dk≈Ø p≈ôi naƒçten√≠ z programList
n');
                                this.parser.parse(program);                                const numberedLines = lines.map((line, i) => {
                                this.simulator.updateToolPath(this.parser.toolPath); lineNumber = i + 1;
                            }umber < 10 ? ' ' : '';
                        };efix}${lineNumber}: ${line}`;
                        reader.readAsText(file);
                        this.toggleMenu('right');s.join('\n');
                    };

                    programList.appendChild(div);Path);
                });
            }
        }
Menu('right');
        // Inicializace aplikace po naƒçten√≠ DOM
        window.addEventListener('DOMContentLoaded', () => {
            window.app = new App();
        });
    </script>
</body>
</html>
